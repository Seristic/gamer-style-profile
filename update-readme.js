import { writeFileSync, readFileSync } from 'fs';
import { Octokit } from '@octokit/rest';

const PAT = process.env.PAT_TOKEN;
const USERNAME = process.env.GITHUB_USERNAME;

if (!PAT || !USERNAME) {
  console.error('Missing PAT_TOKEN or GITHUB_USERNAME environment variables');
  process.exit(1);
}

const octokit = new Octokit({ auth: PAT });

// New HTML/CSS XP bar function using Trans Pride gradient
function xpBarHTML(xp) {
  const percent = Math.min(100, Math.max(0, xp)); // xp from 0 to 100

  return `
  <div style="
    width: 200px;
    height: 20px;
    border-radius: 10px;
    background: linear-gradient(
      to right,
      #55CDFC 0%,
      #F7A8B8 25%,
      #FFFFFF 50%,
      #F7A8B8 75%,
      #55CDFC 100%
    );
    position: relative;
    overflow: hidden;
    border: 1px solid #ccc;
  ">
    <div style="
      height: 100%;
      width: ${100 - percent}%;
      background-color: rgba(255, 255, 255, 0.8);
      position: absolute;
      top: 0;
      left: ${percent}%;
      transition: width 0.5s ease;
    "></div>
  </div>`;
}

// Fetch commit count for a single repo using the contributors stats API
async function getCommitCountForRepo(owner, repoName) {
  try {
    const stats = await octokit.repos.getContributorsStats({
      owner,
      repo: repoName,
    });

    if (!stats.data) return 0;

    // Find your contributions data
    const userStats = stats.data.find(contributor => contributor.author?.login?.toLowerCase() === USERNAME.toLowerCase());
    if (!userStats) return 0;

    return userStats.total;
  } catch (e) {
    if (e.status === 202) {
      // Stats are being generated by GitHub; warn and return 0 for now
      console.warn(`Stats for repo "${repoName}" are being generated, returning 0 commits for now.`);
      return 0;
    }
    console.error(`Error fetching commit stats for repo "${repoName}":`, e);
    return 0;
  }
}

async function getStats() {
  const repos = await octokit.paginate(octokit.repos.listForUser, {
    username: USERNAME,
    per_page: 100,
  });

  // Calculate actual commits by summing commit counts for each repo
  let totalCommits = 0;
  for (const repo of repos) {
    const count = await getCommitCountForRepo(USERNAME, repo.name);
    totalCommits += count;
  }

  const issues = await octokit.paginate(octokit.issues.listForUser, {
    username: USERNAME,
    filter: 'created',
    state: 'all',
    per_page: 100,
  });

  const prsResult = await octokit.search.issuesAndPullRequests({
    q: `is:pr author:${USERNAME}`,
    per_page: 1,
  });
  const totalPRs = prsResult.data.total_count;

  const mergedPRsResult = await octokit.search.issuesAndPullRequests({
    q: `is:pr author:${USERNAME} is:merged`,
    per_page: 1,
  });
  const mergedPRs = mergedPRsResult.data.total_count;

  const userData = await octokit.users.getByUsername({ username: USERNAME });
  const followers = userData.data.followers;

  let totalStars = 0;
  for (const repo of repos) {
    totalStars += repo.stargazers_count;
  }

  let totalComments = 0;
  for (const repo of repos) {
    const issueComments = await octokit.paginate(octokit.issues.listCommentsForRepo, {
      owner: USERNAME,
      repo: repo.name,
      per_page: 100,
    });
    totalComments += issueComments.filter(c => c.user.login === USERNAME).length;

    const prReviewComments = await octokit.paginate(octokit.pulls.listReviewCommentsForRepo, {
      owner: USERNAME,
      repo: repo.name,
      per_page: 100,
    });
    totalComments += prReviewComments.filter(c => c.user.login === USERNAME).length;
  }

  return {
    commits: totalCommits,
    issues: issues.length,
    prs: totalPRs,
    mergedPRs,
    repos: repos.length,
    followers,
    stars: totalStars,
    comments: totalComments,
  };
}

function calculateLevel(xp) {
  return Math.floor(xp / 100);
}

function calculateXP(xp) {
  return xp % 100;
}

function calculateTotalXP(stats) {
  return (
    stats.commits * 1 +         // 1 XP per commit
    stats.issues * 5 +          // 5 XP per issue opened
    stats.prs * 10 +            // 10 XP per PR created
    stats.mergedPRs * 20 +      // 20 XP per merged PR
    stats.comments * 2 +        // 2 XP per comment made
    stats.stars * 3 +           // 3 XP per star received
    stats.followers * 10        // 10 XP per follower
  );
}

async function main() {
  try {
    console.log('Fetching GitHub stats for', USERNAME);
    const stats = await getStats();

    const totalXP = calculateTotalXP(stats);
    const level = calculateLevel(totalXP);
    const xp = calculateXP(totalXP);
    const bar = xpBarHTML(xp);
    const nextXP = 100 - xp;

    console.log(`Level: ${level}, XP: ${xp}, Total XP: ${totalXP}`);

    let template = readFileSync('README.template.md', 'utf-8');

    // Trans pride flag HTML snippet
    const transFlag = `
<p align="center">
  <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a1/Transgender_Pride_flag.svg/320px-Transgender_Pride_flag.svg.png" alt="Trans Pride Flag" width="200" />
</p>
`;

    // Replace placeholders in the README template
    template = template
      .replace(/{{USERNAME}}/g, USERNAME)
      .replace(/{{LEVEL}}/g, level.toString())
      .replace(/{{XP_BAR}}/g, bar)
      .replace(/{{XP}}/g, xp.toString())
      .replace(/{{NEXT_XP}}/g, nextXP.toString())
      .replace(/{{COMMITS}}/g, stats.commits.toString())
      .replace(/{{ISSUES}}/g, stats.issues.toString())
      .replace(/{{PRS}}/g, stats.prs.toString())
      .replace(/{{MERGEDPRS}}/g, stats.mergedPRs.toString())
      .replace(/{{COMMENTS}}/g, stats.comments.toString())
      .replace(/{{STARS}}/g, stats.stars.toString())
      .replace(/{{FOLLOWERS}}/g, stats.followers.toString())
      .replace(/{{REPOS}}/g, stats.repos.toString())
      .replace(/{{TRANS_FLAG}}/g, transFlag);

    writeFileSync('README.md', template);

    console.log('README.md updated!');
  } catch (err) {
    console.error('Error:', err);
    process.exit(1);
  }
}

main();
